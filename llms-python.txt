# PixCI Python Code Engine
> PixCI Python Library l√† m·ªôt th∆∞ vi·ªán h·ªó tr·ª£ Tr√≠ tu·ªá Nh√¢n t·∫°o (LLMs) v·∫Ω Pixel Art d∆∞·ªõi d·∫°ng m√£ l·∫≠p tr√¨nh Python (Procedural Python Code) v·ªõi ƒë·ªô ch√≠nh x√°c v√† t√≠nh th·∫©m m·ªπ cao. B·∫±ng c√°ch s·ª≠ d·ª•ng c√°c h√†m API ng·ªØ nghƒ©a (Semantic Spatial API), AI kh√¥ng c·∫ßn ph·∫£i t√≠nh to√°n t·ª´ng t·ªça ƒë·ªô pixel th·ªß c√¥ng.

## 1. Kh·ªüi t·∫°o Canvas & Ti·ªán √≠ch
M·ªçi d·ª± √°n b·∫Øt ƒë·∫ßu b·∫±ng vi·ªác import th∆∞ vi·ªán v√† t·∫°o Canvas.
```python
import pixci
canvas = pixci.Canvas(32, 32)
```
- `canvas.clear(color)`: X√≥a active layer ho·∫∑c t√¥ To√†n b·ªô b·∫±ng 1 m√†u.
- `canvas.save("output_name.png", scale=10)`: L∆∞u file (scale=10 ƒë·ªÉ ph√≥ng to 10 l·∫ßn).
- `canvas.preview()`: D√πng ƒë·ªÉ in ra ASCII d·∫°ng text xem tr∆∞·ªõc tr√™n terminal l∆∞·ªõi pixel (Gi√∫p AI g·ª° l·ªói).
- `canvas.load_image("path.png", (x, y))`: Load m·ªôt ·∫£nh PNG b√™n ngo√†i ƒë·∫Øp v√†o layer hi·ªán t·∫°i.
- `canvas.get_pixel((x, y))`: ƒê·ªçc m√£ m√†u RGBA c·ªßa m·ªôt ƒëi·ªÉm ·∫£nh.

## 2. H·ªá th·ªëng B·∫£ng m√†u & Hue-Shifting (M√†u s·∫Øc)
V·∫Ω Pixel Art c·∫ßn qu·∫£n l√Ω b·∫±ng b·∫£ng m√†u h·∫°n ch·∫ø (Palette), kh√¥ng d√πng tr·ª±c ti·∫øp m√£ HEX khi v·∫Ω.
- **D√πng Palette c√≥ s·∫µn:** H·ªó tr·ª£ h∆°n 4000 b·∫£ng m√†u (t·ª´ Lospec/Cache).
  `canvas.load_palette("endesga-32", prefix="E_")`
- **Khai b√°o m√†u th·ªß c√¥ng:**
  `canvas.add_palette({"R1": "#E62E2DFF", "G1": "#1E1A20FF"})`
  `canvas.add_color("R1", "#E62E2DFF")`
- **Sinh m√†u s√°ng t·ªëi t·ª± ƒë·ªông (Hue-Shift):**
  `shades = canvas.auto_shade("#E62E2D", levels=2)` -> Tr·∫£ v·ªÅ dict: `{"dark2", "dark1", "base", "light1", "light2"}`.
  `canvas.add_palette(shades)`
- **T·∫°o d·∫£i m√†u chuy√™n nghi·ªáp (Color Ramp):** Sinh ra list c√°c m√†u gradient thay ƒë·ªïi c·∫£ s·∫Øc ƒë·ªô (hue) ƒë·ªÉ l√†m b√≥ng/ph·∫£n quang r·∫•t x·ªãn.
  `ramp = canvas.generate_ramp("#E8A87C", steps=5, mode="hue_shift")` -> List ch·ª©a 5 m√†u t·ª´ t·ªëi ƒë·∫øn s√°ng.
- **L·∫•y m√†u t∆∞∆°ng ph·∫£n:** `canvas.complementary("base_color")`
- **Danh s√°ch b·∫£ng m√†u offline:** `canvas.list_palettes()`

## 3. H·ªá th·ªëng H·ªó tr·ª£ T·ªça ƒë·ªô (Spatial Helpers)
Tr√°nh c·ªông tr·ª´ th·ªß c√¥ng. H√£y d√πng c√°c h√†m d∆∞·ªõi ƒë√¢y ƒë·ªÉ l·∫•y bi·∫øn m·ªëc tr∆∞·ªõc khi v·∫Ω:
- `cx, cy = canvas.get_center()`: Trung t√¢m canvas.
- `ground_y = canvas.get_ground(margin=2)`: T·ªça ƒë·ªô y m·∫∑t ƒë·∫•t ƒë·ªÉ ƒë·∫∑t ch√¢n v·∫≠t th·ªÉ.
- `y_new = canvas.anchor_above(base_y, offset)` / `anchor_below()`: D·ªãch Y l√™n/xu·ªëng.
- `x_new = canvas.anchor_left_of(base_x, offset)` / `anchor_right_of()`: D·ªãch X tr√°i/ph·∫£i.
- `x0, x1 = canvas.span(center_x, size)`: T√≠nh x_start v√† x_end ƒë·ªëi x·ª©ng qua t√¢m.
- `x0, y0, x1, y1 = canvas.bbox(cx, cy, w, h)`: T√≠nh Bounding box ƒë·ªëi x·ª©ng t·ª´ t√¢m.

## 4. Qu·∫£n l√Ω L·ªõp (Layering) & Snapshot
Quy ho·∫°ch h√¨nh t·ª´ xa t·ªõi g·∫ßn.
- `canvas.add_layer("name")`: T·∫°o v√† chuy·ªÉn sang layer m·ªõi.
- `canvas.set_layer("name")`: Chuy·ªÉn ƒë·ªïi active layer.
- `canvas.delete_layer("name")`
- `canvas.reorder_layers(["bg", "fg"])`
- `canvas.alpha_lock = True/False`: Khi True, ch·ªâ v·∫Ω ƒë√® l√™n v√πng ƒê√É C√ì M√ÄU.
- `canvas.merge_layers("base", "top", mode="normal")` (Modes: 'normal', 'multiply', 'add')
- `canvas.merge_all()`
- `snap = canvas.snapshot()` / `canvas.restore_snapshot(snap)`: L∆∞u v√† Kh√¥i ph·ª•c layer state hi·ªán t·∫°i (Undo).

## 5. V·∫Ω H√¨nh H·ªçc C∆° B·∫£n & Ch·∫ø ƒê·ªô T·∫©y (Eraser Mode)
**M·∫πo Nh·∫•n M·∫°nh:** Truy·ªÅn truy·ªÅn t√™n m√£ m√†u (V√≠ d·ª•: "R1"). N·∫øu truy·ªÅn chu·ªói `"CLEAR"` v√†o m√†u s·∫Øc, l·ªánh v·∫Ω ƒë√≥ s·∫Ω ngay l·∫≠p t·ª©c bi·∫øn th√†nh **c·ª•c T·∫©y (Eraser)**, ƒë·ª•c l·∫πm layer hi·ªán t·∫°i th√†nh trong su·ªët xuy√™n th·∫•u ƒë·ªÉ t·∫°o c√°c h√¨nh kho√©t h·ªØu c∆° (M·∫∑t trƒÉng khuy·∫øt, M·∫Øt r·ªóng).

- `canvas.set_pixel((x, y), "color")`
- `canvas.draw_line((x0,y0), (x1,y1), "color", thickness=1)`
- `canvas.draw_polyline([(x,y)...], "color", closed=True/False, thickness=1)`
- `canvas.draw_curve(start, control, end, "color", thickness=1)` / `draw_cubic_curve(p0, p1, p2, p3, "color", thickness=1)` (Pixel-perfect Curves)
- `canvas.fill_rect((x0,y0), (x1,y1), "color")` / `fill_rounded_rect((x0,y0), (x1,y1), radius, "color")`
- `canvas.fill_circle((cx, cy), radius, "color")` / `draw_circle((cx, cy), radius, "color", pixel_perfect=True)`
- `canvas.fill_ellipse((cx, cy), rx, ry, "color")` / `draw_ellipse((cx, cy), rx, ry, "color", pixel_perfect=True)`
- `canvas.fill_polygon([(x1,y1), (x2,y2)...], "color")`
- `canvas.fill_gradient((x0,y0,x1,y1), ["dark", "mid", "light"], mode="vertical")`: (Modes: 'vertical', 'horizontal', 'diagonal_down', 'diagonal_up')
- `canvas.fill_noise((x0,y0,x1,y1), ["c1", "c2"], density=0.5)`
- `canvas.draw_rows([(y, x_start, x_end, "color"), ...])`: Si√™u n√©n, v·∫Ω nhi·ªÅu d√≤ng d·∫£i ngang ngang 1 l√∫c (d√πng t·∫°o h√¨nh).

## 6. V·∫Ω H√¨nh Ng·ªØ Nghƒ©a & Kh·ªëi Neo (Semantic Shapes)
C√°ch t·ªët nh·∫•t ƒë·ªÉ ch·∫∑n block h√¨nh kh·ªëi chung cho nh√¢n v·∫≠t m√† kh√¥ng c·∫ßn cƒÉn t·ªça ƒë·ªô ph·ª©c t·∫°p.
- `canvas.fill_rect_centered((cx, cy), w, h, "color")`
- `canvas.fill_ellipse_anchored((ax, ay), rx, ry, "color", align="bottom")` (align: "center", "bottom", "top")
- `canvas.fill_rect_anchored((ax, ay), w, h, "color", align="bottom_left")` (align: "center", "bottom", "top", "bottom_left", "bottom_right")

> **üöÄ T∆∞ Duy ƒêi√™u Kh·∫Øc (Sculpting Workflow) cho AI:**
> Thay v√¨ ch·∫•m t·ª´ng ƒëi·ªÉm pixel t·ªën th·ªùi gian, AI n√™n t·∫°o h√¨nh theo t∆∞ duy ƒêi√™u Kh·∫Øc ƒê·∫•t S√©t: 
> 1. D√πng c√°c th·∫ª Block Neo (Neo th√¢n h√¨nh b·∫±ng `fill_rect_anchored` / `ellipse_anchored` to ƒë√πng ng√£ ng·ª≠a).
> 2. ƒê·ªïi color th√†nh `"CLEAR"` -> ƒë·ª•c l·∫•y l·∫°i c√°c g√≥c bo cho h·ª£p l√Ω, v√°t ch√©o vai, tai, m·∫£ng b·ªã th∆∞∆°ng... 
> 3. B·∫≠t kh√≥a `canvas.alpha_lock = True`.
> 4. Ph·ªß b√≥ng ƒë·ªï B√≥ng/S√°ng b·∫±ng `fill_gradient`, `fill_noise` hay r·∫£i Line l√™n m√† KH√îNG S·ª¢ LEM m√†u trong su·ªët.
> 5. Ch·∫°y Postprocess (`cleanup_jaggies`, `add_outline`). Xong! T·∫°o ki·ªát t√°c kh√¥ng c·∫ßn nh√∫ng n√£o!


## 7. Bi·∫øn ƒë·ªïi & Ch·ªânh S·ª≠a (Transform)
- `canvas.translate(dx, dy)`: D·ªãch chuy·ªÉn to√†n v·∫πn m·∫£ng pixel c·ªßa layer hi·ªán t·∫°i.
- `canvas.flip_x()` / `canvas.flip_y()`: L·∫≠t ch·∫£o qua tr·ª•c.
- `canvas.mirror_x(axis_x)` / `canvas.mirror_y(axis_y)`: T·∫°o ·∫£nh ƒë·ªëi x·ª©ng, copy n·ª≠a n√†y l·∫≠t sang n·ª≠a kia.
- `canvas.fill_bucket((x,y), "color")`: T√¥ m√†u th√πng s∆°n cho v√πng k√≠n.
- **L√†m vi·ªác v·ªõi V√πng C·∫Øt (Copy/Paste):**
  - `copied = canvas.copy_region((x0,y0), (x1,y1))`
  - `canvas.paste_region(copied, (x, y), skip_transparent=True)`
  - `canvas.stamp((x0,y0), (x1,y1), target=(x,y))`: Shortcut copy v√† d√°n ngay.
  - `canvas.paste(other_canvas_obj, (x,y))`

## 8. ƒê·ªï B√≥ng & X·ª≠ l√Ω H·∫≠u k·ª≥ (Rendering & Post-processing)
Th∆∞·ªùng l√†m t·ª´ n·ª≠a sau qu√° tr√¨nh v·∫Ω.
- `canvas.fill_dither((x0,y0,x1,y1), "c1", "c2", pattern="checkered")`: Tr·ªôn pixel ('bayer', '25_percent', '50_percent').
- Kh·ªëi C·∫ßu:
  - `canvas.draw_sphere((cx, cy), radius, ["dark", "mid", "light"], light_dir="top_left")`
  - `canvas.draw_half_sphere((cx, cy), radius, ["d","m","l"], light_dir="top_left")`
  - `canvas.fill_cylinder((cx, base_y), w, h, ["d","m","l"], light_dir="top_left")`
- L·ªõp B√≥ng (Shadow/Highlights):
  - `canvas.apply_shadow_mask((cx, cy), radius, light_dir="top_left", intensity=0.5)`: B√≥ng c·∫ßu ƒë·ªï.
  - `canvas.apply_directional_shadow(light_dir="top_left", intensity=0.3)`: B√≥ng d·∫πt to√†n m·∫∑t canvas (cho v·∫≠t th·ªÉ d·∫πp/d√†i).
  - `canvas.add_highlight_edge(light_dir="top_left", intensity=0.2)`: Vi·ªÅn b√≥ng s√°ng (rim light).
- Vi·ªÅn Ngo√†i & ƒê·∫πp c·∫°nh:
  - `canvas.add_outline(thickness=1, sel_out=True)`: `sel_out=True` s·∫Ω d√πng m√†u t·ª± ƒë·ªông t·ª´ n·ªôi b·ªô ƒë·ªÉ l√†m vi·ªÅn th√¥ng minh (thay v√¨ v·ª©t vi·ªÅn ƒëen).
  - `canvas.cleanup_jaggies()`: Kh·ª≠ ƒëi·ªÉm ·∫£nh th·ª´a c·ª©ng ng·∫Øc (rƒÉng c∆∞a/l-shapes).
  - `canvas.apply_internal_aa()`: Smoothens (kh·ª≠ rƒÉng c∆∞a) vi·ªÅn gi·ªØa 2 m√†u n·ªôi b·ªô (Anti-aliasing).

## 9. H·ªá th·ªëng Animation (·∫¢nh ƒë·ªông)
B·∫°n c√≥ th·ªÉ c·∫•u tr√∫c c√°c frames v√† li√™n k·∫øt ch√∫ng th√†nh spritesheet/gif b·∫±ng class `Animation`.
```python
import pixci
anim = pixci.Animation(32, 32, columns=4, fps=5)

# C·∫•u h√¨nh palette (d√πng chung cho m·ªçi frame)
anim.add_palette({"09": "#6ABE30FF", "10": "#37946EFF"})
# ho·∫∑c d√πng: anim.load_palette("pico-8") / anim.auto_shade(...)

# T·∫°o m·ªôt Canvas component (ƒë·ªÉ t√°i s·ª≠ d·ª•ng l√†m body)
body = pixci.Canvas(32, 32)
# T·ª± v·∫Ω m·ªôt th√¢n h√¨nh tu·ª≥ bi·∫øn (Kh√¥ng d√πng macro c·ª©ng)
body.fill_rect_anchored((16, 28), 12, 10, "09", align="bottom")
body.fill_ellipse_anchored((16, 18), 6, 4, "10", align="bottom")

# Frame 1
f1 = anim.add_frame()
f1.paste(body, (0, 0)) # copy canvas v√¥ frame g·ªëc
f1.add_outline(thickness=1, sel_out=False) # X·ª≠ l√Ω h·∫≠u k·ª≥ t·ª´ng frame

# Frame 2
f2 = anim.add_frame()
f2.paste(body, (0, -4)) # Di chuy·ªÉn to√†n kh·ªëi body l√™n 4 pixels (n·∫£y l√™n)
f2.add_outline(thickness=1, sel_out=False)

# T·ª± ƒë·ªông t·∫°o jump.png (spritesheet l∆∞·ªõi ngang) v√† jump.gif
anim.save("jump.png", scale=10) 
```
